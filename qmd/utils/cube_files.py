"""
Cube file I/O for electron density data.

Gaussian cube file format for storing 3D scalar data like electron densities.
"""

import numpy as np
import os
from ase import Atoms
from ..utils.results_utils import ensure_results_dir, get_results_path

def write_cube_file(filename, atoms, density, grid_coords, comment="Electron density", use_results_dir=True):
    """
    Write density data to Gaussian cube file format.

    Parameters:
    -----------
    filename : str
        Output cube file path (will be placed in results/cube_files/ if use_results_dir=True)
    atoms : ASE Atoms object
        Molecular structure
    density : np.ndarray
        3D density array (nx, ny, nz)
    grid_coords : tuple
        (x, y, z) coordinate arrays in Angstrom
    comment : str
        Comment line for cube file
    use_results_dir : bool
        If True, save to results/cube_files/ directory (default: True)
    """
    if use_results_dir and not filename.startswith('./results/'):
        filename = get_results_path(filename, "cube_files")
    x, y, z = grid_coords
    nx, ny, nz = density.shape

    # Grid spacing in Bohr
    bohr_per_angstrom = 1.88973  # conversion factor
    dx = (x[1] - x[0]) * bohr_per_angstrom
    dy = (y[1] - y[0]) * bohr_per_angstrom
    dz = (z[1] - z[0]) * bohr_per_angstrom

    # Origin in Bohr
    origin = np.array([x[0], y[0], z[0]]) * bohr_per_angstrom

    # Atomic positions in Bohr
    positions_bohr = atoms.get_positions() * bohr_per_angstrom
    atomic_numbers = atoms.get_atomic_numbers()

    with open(filename, 'w') as f:
        # Header lines
        f.write(f" {comment}\n")
        f.write(" Generated by QMD framework\n")

        # Number of atoms and origin
        f.write(f"{len(atoms):5d} {origin[0]:12.6f} {origin[1]:12.6f} {origin[2]:12.6f}\n")

        # Grid vectors (number of points and step vectors)
        f.write(f"{nx:5d} {dx:12.6f}  0.000000  0.000000\n")
        f.write(f"{ny:5d}  0.000000 {dy:12.6f}  0.000000\n")
        f.write(f"{nz:5d}  0.000000  0.000000 {dz:12.6f}\n")

        # Atomic coordinates
        for i, (z_num, pos) in enumerate(zip(atomic_numbers, positions_bohr)):
            f.write(f"{z_num:5d}  0.000000 {pos[0]:12.6f} {pos[1]:12.6f} {pos[2]:12.6f}\n")

        # Density data (6 values per line)
        values_per_line = 6
        flat_density = density.flatten()

        for i in range(0, len(flat_density), values_per_line):
            line_values = flat_density[i:i+values_per_line]
            line = "".join(f"{val:13.5E}" for val in line_values)
            f.write(line + "\n")

def read_cube_file(filename):
    """
    Read Gaussian cube file and return density data.

    Parameters:
    -----------
    filename : str
        Cube file path

    Returns:
    --------
    atoms : ASE Atoms object
        Molecular structure
    density : np.ndarray
        3D density array
    grid_coords : tuple
        (x, y, z) coordinate arrays in Angstrom
    """
    with open(filename, 'r') as f:
        lines = f.readlines()

    # Skip comment lines
    line_idx = 2

    # Parse header
    natoms_line = lines[line_idx].split()
    natoms = int(natoms_line[0])
    origin = np.array([float(x) for x in natoms_line[1:4]]) / 1.88973  # Bohr to Angstrom
    line_idx += 1

    # Parse grid vectors
    grid_info = []
    for i in range(3):
        grid_line = lines[line_idx].split()
        npts = int(grid_line[0])
        vector = np.array([float(x) for x in grid_line[1:4]]) / 1.88973  # Bohr to Angstrom
        grid_info.append((npts, vector))
        line_idx += 1

    nx, dx_vec = grid_info[0]
    ny, dy_vec = grid_info[1]
    nz, dz_vec = grid_info[2]

    # Create coordinate arrays
    x = origin[0] + np.arange(nx) * dx_vec[0]
    y = origin[1] + np.arange(ny) * dy_vec[1]
    z = origin[2] + np.arange(nz) * dz_vec[2]

    # Parse atomic coordinates
    symbols = []
    positions = []

    for i in range(natoms):
        atom_line = lines[line_idx].split()
        atomic_number = int(atom_line[0])
        pos = np.array([float(x) for x in atom_line[2:5]]) / 1.88973  # Bohr to Angstrom

        # Convert atomic number to symbol
        from ase.data import chemical_symbols
        symbols.append(chemical_symbols[atomic_number])
        positions.append(pos)
        line_idx += 1

    atoms = Atoms(symbols=symbols, positions=positions)

    # Parse density data
    density_lines = lines[line_idx:]
    density_text = "".join(density_lines)
    density_values = np.array([float(x) for x in density_text.split()])

    # Reshape to 3D grid
    density = density_values.reshape((nx, ny, nz))

    return atoms, density, (x, y, z)

def export_density_for_vmd(filename, density, grid_coords, use_results_dir=True):
    """
    Export density in VMD-compatible format.

    Parameters:
    -----------
    filename : str
        Output filename (will append .dx and place in results/exports/ if use_results_dir=True)
    density : np.ndarray
        3D density array
    grid_coords : tuple
        (x, y, z) coordinate arrays
    use_results_dir : bool
        If True, save to results/exports/ directory (default: True)
    """
    if use_results_dir and not filename.startswith('./results/'):
        filename = get_results_path(filename, "exports")
    x, y, z = grid_coords
    nx, ny, nz = density.shape

    dx = x[1] - x[0]
    dy = y[1] - y[0]
    dz = z[1] - z[0]

    with open(f"{filename}.dx", 'w') as f:
        # DX format header
        f.write("# Data from QMD framework\n")
        f.write(f"object 1 class gridpositions counts {nx} {ny} {nz}\n")
        f.write(f"origin {x[0]:.6f} {y[0]:.6f} {z[0]:.6f}\n")
        f.write(f"delta {dx:.6f} 0 0\n")
        f.write(f"delta 0 {dy:.6f} 0\n")
        f.write(f"delta 0 0 {dz:.6f}\n")
        f.write(f"object 2 class gridconnections counts {nx} {ny} {nz}\n")
        f.write(f"object 3 class array type double rank 0 items {nx*ny*nz} data follows\n")

        # Data values (3 per line for DX format)
        flat_density = density.flatten()
        for i in range(0, len(flat_density), 3):
            line_values = flat_density[i:i+3]
            line = " ".join(f"{val:.6E}" for val in line_values)
            f.write(line + "\n")

        f.write("attribute \"dep\" string \"positions\"\n")
        f.write("object \"regular positions regular connections\" class field\n")
        f.write("component \"positions\" value 1\n")
        f.write("component \"connections\" value 2\n")
        f.write("component \"data\" value 3\n")

def cube_info(filename):
    """
    Print information about a cube file.

    Parameters:
    -----------
    filename : str
        Cube file path
    """
    try:
        atoms, density, grid_coords = read_cube_file(filename)
        x, y, z = grid_coords

        print(f"Cube file: {filename}")
        print(f"Number of atoms: {len(atoms)}")
        print(f"Grid dimensions: {density.shape}")
        print(f"Grid spacing: ({x[1]-x[0]:.3f}, {y[1]-y[0]:.3f}, {z[1]-z[0]:.3f}) Å")
        print(f"Grid range: X({x.min():.2f}, {x.max():.2f}) Y({y.min():.2f}, {y.max():.2f}) Z({z.min():.2f}, {z.max():.2f}) Å")
        print(f"Density range: ({density.min():.6f}, {density.max():.6f})")
        print(f"Molecular formula: {atoms.get_chemical_formula()}")

    except Exception as e:
        print(f"Error reading cube file: {e}")

# Convenience functions
def save_density_cube(system, density, grid_coords, filename, comment="Electron density", use_results_dir=True):
    """Save QMD system density to cube file."""
    write_cube_file(filename, system.atoms, density, grid_coords, comment, use_results_dir)

def load_density_cube(filename):
    """Load density from cube file, return atoms, density, grid."""
    # If filename doesn't include path, try both current dir and results dir
    if not os.path.dirname(filename):
        results_path = get_results_path(filename, "cube_files")
        if os.path.exists(results_path):
            filename = results_path
    return read_cube_file(filename)